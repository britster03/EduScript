# interpreter.py

import pygame
import sys
import time
from parser import build_parser, Program, FunctionDef, Command, IfStatement, RepeatLoop, FunctionCall, ReturnStatement, BinaryOp, UnaryOp, Number, Identifier
import textwrap
import math

class Environment:
    # initializing an environment with an empty variable dictionary
    # accepts an optional parent environment for nested scopes
    def __init__(self, parent=None):
        self.vars = {}
        self.parent = parent

    def get(self, name):
        # tetrieving the value of a variable
        # first searches the current environment; if not found, recursively searches parent environments
        if name in self.vars:
            return self.vars[name]
        elif self.parent:
            return self.parent.get(name)
        else:
            raise Exception(f"Undefined variable '{name}'")

    # assigns a value to a variable in the current environment
    def set(self, name, value):
        self.vars[name] = value

class Interpreter:
    def __init__(self, ast, simulator):
        self.ast = ast # Abstract Syntax Tree generated by the parser
        self.functions = {} # dictionary to store user-defined functions
        self.global_env = Environment() # global environment for variable storage
        self.current_env = self.global_env
        self.simulator = simulator  # reference to the Simulator responsible for executing the robot actions
        self.built_in_functions = {
            'detectObstacle': self.built_in_detect_obstacle,
            'measureDistance': self.built_in_measure_distance
        }

    def interpret(self):
        for func in self.ast.functions:
            self.functions[func.name] = func

        if 'main' not in self.functions:
            raise Exception("No 'main' function defined.")

        self.execute_function('main', [])

    def execute_function(self, name, args):
        # if the function name matches a built-in function, it calls the corresponding implementation
        if name in self.built_in_functions:
            return self.built_in_functions[name](args)
        elif name in self.functions:
            func = self.functions[name]
            env = Environment(parent=self.global_env)
            previous_env = self.current_env
            self.current_env = env
            try:
                self.execute_statements(func.body)
            except ReturnException as ret:
                self.current_env = previous_env
                return ret.value
            self.current_env = previous_env
        else:
            raise Exception(f"Undefined function '{name}'")

# iterates through a list of statements and executes each one
    def execute_statements(self, statements):
        for stmt in statements:
            self.execute_statement(stmt)
# determining the type of statement and delegates execution to the appropriate method
    def execute_statement(self, stmt):
        if isinstance(stmt, Command):
            self.execute_command(stmt)
        elif isinstance(stmt, IfStatement):
            condition = self.evaluate_expression(stmt.condition)
            if condition:
                self.execute_statements(stmt.if_body)
            elif stmt.else_body is not None:
                self.execute_statements(stmt.else_body)
        elif isinstance(stmt, RepeatLoop):
            times = self.evaluate_expression(stmt.times)
            for _ in range(int(times)):
                self.execute_statements(stmt.body)
        elif isinstance(stmt, FunctionCall):
            self.execute_function(stmt.name, stmt.args)
        elif isinstance(stmt, ReturnStatement):
            value = self.evaluate_expression(stmt.expression)
            raise ReturnException(value)
        else:
            raise Exception(f"Unknown statement type: {type(stmt)}")

#  maps EduScript commands (moveForward, turnRight, etc.) to simulator actions by enqueuing them
    def execute_command(self, cmd):
        command = cmd.command
        args = [self.evaluate_expression(arg) for arg in cmd.args]
        # implementing the robotic commands
        if command == 'moveForward':
            distance = args[0]
            self.simulator.enqueue_action('move_forward', distance)
        elif command == 'moveBackward':
            distance = args[0]
            self.simulator.enqueue_action('move_backward', distance)
        elif command == 'turnRight':
            angle = args[0]
            self.simulator.enqueue_action('turn_right', angle)
        elif command == 'turnLeft':
            angle = args[0]
            self.simulator.enqueue_action('turn_left', angle)
        else:
            raise Exception(f"Unknown command '{command}'")

# recursively evaluates expressions, handling numbers, identifiers, binary operations, unary operations, and function calls
    def evaluate_expression(self, expr):
        if isinstance(expr, Number):
            return expr.value
        elif isinstance(expr, Identifier):
            return self.current_env.get(expr.name)
        elif isinstance(expr, BinaryOp):
            left = self.evaluate_expression(expr.left)
            right = self.evaluate_expression(expr.right)
            return self.apply_binary_op(expr.op, left, right)
        elif isinstance(expr, UnaryOp):
            operand = self.evaluate_expression(expr.operand)
            return self.apply_unary_op(expr.op, operand)
        elif isinstance(expr, FunctionCall):
            return self.execute_function(expr.name, expr.args)
        else:
            raise Exception(f"Unknown expression type: {type(expr)}")

    def apply_binary_op(self, op, left, right):
        if op == '+':
            return left + right
        elif op == '-':
            return left - right
        elif op == '*':
            return left * right
        elif op == '/':
            return left / right
        elif op == '==':
            return left == right
        elif op == '!=':
            return left != right
        elif op == '<':
            return left < right
        elif op == '<=':
            return left <= right
        elif op == '>':
            return left > right
        elif op == '>=':
            return left >= right
        elif op == '&&':
            return left and right
        elif op == '||':
            return left or right
        else:
            raise Exception(f"Unknown binary operator '{op}'")

    def apply_unary_op(self, op, operand):
        if op == '!':
            return not operand
        else:
            raise Exception(f"Unknown unary operator '{op}'")

# simulates obstacle detection (currently always returns False).
    def built_in_detect_obstacle(self, args):
        if len(args) != 0:
            raise Exception("detectObstacle() takes no arguments.")
        obstacle_detected = self.simulator.detect_obstacle()
        print(f"detectObstacle() called, returning {obstacle_detected}")
        return obstacle_detected

# simulates distance measurement (currently returns a fixed value of 100).

    def built_in_measure_distance(self, args):
        if len(args) != 0:
            raise Exception("measureDistance() takes no arguments.")
        distance = self.simulator.measure_distance()
        print(f"measureDistance() called, returning {distance}")
        return distance

class ReturnException(Exception):
    def __init__(self, value):
        self.value = value

class Simulator:
    def __init__(self):
        pygame.init() # initialzing pygame
        self.width, self.height = 800, 600
        self.screen = pygame.display.set_mode((self.width, self.height))
        pygame.display.set_caption("EduScript Robot Simulation")
        self.clock = pygame.time.Clock()
        self.robot_pos = [400.0, 300.0]  #  robot's starting position at the center of the window
        self.robot_angle = 0  # initializing the robots's angle , 0 degrees pointing to the right
        self.robot_size = 20
        self.font = pygame.font.SysFont(None, 24)

        # initializing the action_queue, current_action, and action_progress to manage robot actions
        self.action_queue = []
        self.current_action = None
        self.action_progress = 0  # tracking progress within the current action

        self.move_speed = 2  # units per frame
        self.turn_speed = 2  # degrees per frame

    def enqueue_action(self, action_type, value):
        # action_type: Type of action (move_forward, turn_right, etc.).
        # value: Distance (units) or angle (degrees) associated with the action.
        # adds the action to the action_queue and prints a message indicating the enqueued action
        self.action_queue.append((action_type, value))
        print(f"Enqueued action: {action_type} with value {value}")

    def update_actions(self):
        # if no action is currently being executed (current_action is None) and there are actions in the queue, 
        # dequeues the next action and starts it
        if self.current_action is None and self.action_queue:
            self.current_action = self.action_queue.pop(0)
            self.action_progress = 0
            print(f"Starting action: {self.current_action}")
        
        # Action Execution:
        # Movement:
        # calculates the direction (1 for forward, -1 for backward)
        # determines the step size based on move_speed and remaining distance
        # updates robot_pos by adding delta_x and delta_y based on the current angle and step size
        # increments action_progress by the step size
        # marks the action as completed if the target distance is reached
        if self.current_action:
            action_type, value = self.current_action
            if action_type in ['move_forward', 'move_backward']:
                direction = 1 if action_type == 'move_forward' else -1
                distance_remaining = value - self.action_progress
                step = self.move_speed if distance_remaining > self.move_speed else distance_remaining
                rad = math.radians(self.robot_angle)
                delta_x = direction * step * math.cos(rad)
                delta_y = direction * step * math.sin(rad)
                self.robot_pos[0] += delta_x
                self.robot_pos[1] += delta_y
                self.action_progress += step
                print(f"Moving {'forward' if direction ==1 else 'backward'}: Step {self.action_progress}/{value}")

                if self.action_progress >= value:
                    print(f"Completed action: {action_type}")
                    self.current_action = None
            # turning:
            # determines the direction (-1 for right, 1 for left).
            # calculates the step size based on turn_speed and remaining angle.
            # updates robot_angle by adding the step size, ensuring it wraps around at 360 degrees.
            # increments action_progress by the step size.
            # marks the action as completed if the target angle is reached.
            elif action_type in ['turn_right', 'turn_left']:
                direction = -1 if action_type == 'turn_right' else 1
                angle_remaining = value - self.action_progress
                step = self.turn_speed if angle_remaining > self.turn_speed else angle_remaining
                self.robot_angle += direction * step
                self.robot_angle %= 360
                self.action_progress += step
                print(f"Turning {'right' if direction == -1 else 'left'}: Step {self.action_progress}/{value}")

                if self.action_progress >= value:
                    print(f"Completed action: {action_type}")
                    self.current_action = None

    def move_forward(self, distance):
        self.enqueue_action('move_forward', distance)

    def move_backward(self, distance):
        self.enqueue_action('move_backward', distance)

    def turn_right(self, angle):
        self.enqueue_action('turn_right', angle)

    def turn_left(self, angle):
        self.enqueue_action('turn_left', angle)

    def detect_obstacle(self):
        obstacle_detected = False
        return obstacle_detected

    def measure_distance(self):
        distance = 100  
        return distance

    def draw_robot(self):
        self.screen.fill((255, 255, 255))  # White background

        pygame.draw.circle(
            self.screen,
            (0, 0, 255),  # blue color
            (int(self.robot_pos[0]), int(self.robot_pos[1])),
            self.robot_size
        )

        # direction indicator
        end_x = self.robot_pos[0] + self.robot_size * math.cos(math.radians(self.robot_angle))
        end_y = self.robot_pos[1] + self.robot_size * math.sin(math.radians(self.robot_angle))
        pygame.draw.line(
            self.screen,
            (255, 0, 0),  # red color
            self.robot_pos,
            (end_x, end_y),
            2  
        )

        # robot position
        position_text = f"Position: ({self.robot_pos[0]:.1f}, {self.robot_pos[1]:.1f})"
        text_surface = self.font.render(position_text, True, (0, 0, 0))
        self.screen.blit(text_surface, (10, 30))

        pygame.display.flip()

    def update_display(self):
        # Update robot actions
        self.update_actions()

        # Draw the robot
        self.draw_robot()

        # Control the loop speed
        self.clock.tick(60)

# inherits from the Interpreter class, extending its functionality to integrate with the simulator's action queue
class InterpreterWithSimulator(Interpreter):
    def __init__(self, ast, simulator):
        super().__init__(ast, simulator)
        self.command_queue = [] # command_queue to hold EduScript commands
        self.populate_command_queue(ast) # fill the queue with commands from the main function

    def populate_command_queue(self, ast):
    # Iterates through all functions in the AST.
    # if a function named main is found, its body (list of statements) is added to the command_queue.
        for func in ast.functions:
            if func.name == 'main':
                self.command_queue.extend(func.body)

    # dequeues the next command from command_queue
    def execute_next_command(self):
        if self.command_queue:
            stmt = self.command_queue.pop(0)
            self.execute_statement(stmt)

    def update(self):
        # Checks if the simulator is idle (no current_action).
        # if idle and commands are pending, executes the next command.
        if not self.simulator.current_action and self.command_queue:
            try:
                self.execute_next_command()
            except Exception as e:
                print(f"Error during interpretation: {e}")

# Main Execution
if __name__ == "__main__":
    parser = build_parser() # calling parser to compile the parser with the defined grammar rules
    data = textwrap.dedent('''\
        function main() {
            moveForward(50);
            turnRight(90);
            moveBackward(50);
            turnLeft(90);
            moveForward(50);
            turnRight(90);
            moveBackward(50);
            turnLeft(90);
        }
    ''')
    ast = parser.parse(data)
    if ast:
        simulator = Simulator()
        interpreter = InterpreterWithSimulator(ast, simulator)
        interpreter.interpret()  # starting interpreting and enqueue actions

        # the simulation loop starts
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()

            # updating and drawing the robot
            simulator.update_display()

            # update interpreter 
            interpreter.update()
    else:
        print("Parsing failed.")
